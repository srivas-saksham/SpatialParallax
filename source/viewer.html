<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR Camera Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #debug {
      position: absolute;
      left: 10px; bottom: 10px;
      background: rgba(0,0,0,0.6);
      color: #fff; padding: 6px 10px;
      font-size: 13px; border-radius: 4px;
      font-family: monospace;
    }
  </style>
</head>
<body>
<div id="debug">Waiting for dataâ€¦</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';

// Scene
const scene = new THREE.Scene();

// Grid floor
const grid = new THREE.GridHelper(10, 20);
scene.add(grid);

// Create multiple light-colored buildings at different positions and heights
const buildings = [];

// Building materials with light colors
const materials = [
  new THREE.MeshLambertMaterial({ color: 0xf0f0f0 }), // Light gray
  new THREE.MeshLambertMaterial({ color: 0xfff8dc }), // Cornsilk
  new THREE.MeshLambertMaterial({ color: 0xf5f5dc }), // Beige
  new THREE.MeshLambertMaterial({ color: 0xe6e6fa }), // Lavender
  new THREE.MeshLambertMaterial({ color: 0xf0fff0 }), // Honeydew
  new THREE.MeshLambertMaterial({ color: 0xfff0f5 }), // Lavender blush
  new THREE.MeshLambertMaterial({ color: 0xf8f8ff }), // Ghost white
  new THREE.MeshLambertMaterial({ color: 0xfffacd })  // Lemon chiffon
];

// Building configurations: [x, z, width, height, depth]
const buildingConfigs = [
  // Front row (closer to camera start position)
  [1.5, 1, 0.4, 0.8, 0.4],
  [-1.2, 0.8, 0.3, 1.2, 0.3],
  [2.8, 0.5, 0.5, 0.6, 0.5],
  
  // Middle row
  [0.2, -1.5, 0.6, 1.5, 0.6],
  [-2.5, -1.8, 0.4, 2.0, 0.4],
  [3.2, -2.0, 0.3, 1.8, 0.3],
  [-0.8, -2.5, 0.5, 1.0, 0.5],
  
  // Back row (further from camera)
  [1.8, -3.5, 0.7, 2.2, 0.7],
  [-1.5, -4.0, 0.4, 1.6, 0.4],
  [0.5, -4.2, 0.6, 2.5, 0.6],
  [-3.0, -3.8, 0.3, 1.4, 0.3],
  [2.2, -4.5, 0.5, 1.9, 0.5],
  
  // Side buildings for peripheral vision
  [4.0, -1.0, 0.4, 1.3, 0.4],
  [-4.2, -0.5, 0.3, 1.7, 0.3],
  [3.8, -3.0, 0.5, 2.1, 0.5],
  [-3.8, -2.8, 0.4, 1.1, 0.4],
  
  // Center landmark building (taller)
  [0, -0.5, 0.8, 3.0, 0.8]
];

// Create buildings
buildingConfigs.forEach((config, index) => {
  const [x, z, width, height, depth] = config;
  
  const building = new THREE.Mesh(
    new THREE.BoxGeometry(width, height, depth),
    materials[index % materials.length]
  );
  
  building.position.set(x, height / 2, z); // Position so building sits on grid
  scene.add(building);
  buildings.push(building);
});

// Original cube (kept as reference point)
const box = new THREE.Mesh(
  new THREE.BoxGeometry(0.3, 0.3, 0.3),
  new THREE.MeshNormalMaterial()
);
box.position.set(0, 0.15, 0); // sits on grid
scene.add(box);

// Debug axes
scene.add(new THREE.AxesHelper(1));

// Add ambient light for the buildings
const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
scene.add(ambientLight);

// Add directional light for better depth perception
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 5);
directionalLight.castShadow = true;
scene.add(directionalLight);

// Camera
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.01,
  100
);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Debug overlay
const debugEl = document.getElementById("debug");

// Latest AR pose
let latestPose = null;

// Movement scaling factor (1 = 1m real = 1 unit in scene)
const SCALE = 2.0;

// WebSocket connection
const socket = new WebSocket("wss://date-males-terminals-ron.trycloudflare.com"); // adjust if needed
socket.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data);
    if (data.position && data.rotation) {
      latestPose = data;
    }
  } catch (e) {
    console.warn("Invalid JSON from server", e);
  }
};

// MODIFICATION: Helper function to extract only yaw (Y-axis rotation) from quaternion
function extractYawFromQuaternion(quaternion) {
  // Create a temporary Euler object to convert quaternion to Euler angles
  const tempEuler = new THREE.Euler();
  tempEuler.setFromQuaternion(quaternion, 'YXZ'); // YXZ order to get yaw first
  
  // Extract only the yaw (Y-axis rotation), zero out pitch (X) and roll (Z)
  const yawOnlyEuler = new THREE.Euler(0, tempEuler.y, 0, 'YXZ');
  
  // Convert back to quaternion with only yaw rotation
  const yawOnlyQuaternion = new THREE.Quaternion();
  yawOnlyQuaternion.setFromEuler(yawOnlyEuler);
  
  return yawOnlyQuaternion;
}

function animate() {
  requestAnimationFrame(animate);

  if (latestPose) {
    // Set camera position normally (translation is not affected)
    camera.position.set(
      latestPose.position.x * SCALE,
      latestPose.position.y * SCALE,
      latestPose.position.z * SCALE
    );
    
    // MODIFICATION: Extract only yaw rotation to prevent tilting
    // Create quaternion from the received rotation data
    const receivedQuaternion = new THREE.Quaternion(
      latestPose.rotation.x,
      latestPose.rotation.y,
      latestPose.rotation.z,
      latestPose.rotation.w
    );
    
    // Extract only yaw (horizontal rotation) and apply to camera
    const yawOnlyQuaternion = extractYawFromQuaternion(receivedQuaternion);
    camera.quaternion.copy(yawOnlyQuaternion);

    debugEl.textContent =
      `pos=(${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})\n` +
      `rot=(${camera.quaternion.x.toFixed(2)}, ${camera.quaternion.y.toFixed(2)}, ${camera.quaternion.z.toFixed(2)}, ${camera.quaternion.w.toFixed(2)})\n` +
      `yaw-only mode active`; // Added indicator that yaw-only mode is active
  } else {
    // Debug fallback: static camera view until AR data arrives
    camera.position.set(0, 1.5, 5);
    camera.lookAt(0, 0.15, 0);
  }

  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>